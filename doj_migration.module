<?php

/**
 * @file
 * THIS SPACE INTENTIONALLY LEFT BLANK.
 *
 * Yes, there is no code in the .module file. Migrate operates almost entirely
 * through classes, and by adding any files containing class definitions to the
 * .info file, those files are automatically included only when the classes they
 * contain are referenced. The one non-class piece you need to implement is
 * hook_migrate_api(), but because .migrate.inc is registered using
 * hook_hook_info by defining your implementation of that hook in
 * mymodule.migrate.inc, it is automatically invoked only when needed.
 *
 * @package doj_migration
 */

/**
 * Implements hook_menu_alter().
 */
function doj_migration_menu_alter(&$items) {
  // Viewing this page calls the contstructors for all registered migration
  // classes, overwhelming PHP memory limit. We cannot disable migrate_ui
  // due to wordpress_migrate dependency on it, so we will instead unset this
  // menu router item.
  unset($items['admin/content/migrate']);
}
/**
 * Move all the images from a directory tree to an output directory.
 *
 * The directory strucuture in the output directory will be an exact match of
 * the directory structury from the source directory.
 *
 * @param string $parent_input_directory
 *   The parent directory where anothe directory with images is located.
 * @param string $directory
 *   The directory that contains images.
 * @param string $parent_output_directory
 *   The directory where we want to save all the images.
 */
function doj_migration_move_images($parent_input_directory, $directory, $parent_output_directory) {

  // Make the directory where our files will go.
  $final_output_directory = "$parent_output_directory/$directory";

  // Get all files from the source directory.
  $final_input_directory = "$parent_input_directory/$directory";
  $files = scandir($final_input_directory);

  foreach ($files as $file) {
    $ext = pathinfo("$final_input_directory/$file", PATHINFO_EXTENSION);

    // If any of the files are images, copy them.
    if ($ext == "gif" || $ext == "png" || $ext == "jpg") {
      // We only want to create the output directory if we have images.
      if (!file_exists($final_output_directory)) {
        mkdir($final_output_directory, 0777, TRUE);
      }

      watchdog("doj_migration", "FILE: @file EXT: @ext \n", array('@file' => $file, 'ext' => $ext));

      if (copy("$final_input_directory/$file", "$final_output_directory/$file")) {
        watchdog("doj_migration", "File @file was copied to $final_output_directory \n", array('@file' => $file));
      }
      else {
        watchdog("doj_migration", "There was an error copying @file \n", array('@file' => $file), WATCHDOG_ERROR);
      }
    }
    // If we are dealing with a directory, let's recurse.
    elseif (is_dir("$final_input_directory/$file") && "{$file}" != "." && "{$file}" != "..") {
      watchdog("doj_migration", "Found a directory {$file} \n");
      doj_migration_move_images($final_input_directory, $file, $final_output_directory);
    }
  }
}

/**
 * Set workbench configration for entity.
 *
 * This fixes a number of bugs that result from worbench revisions failing
 * to be created or updated when entities are created or updated.
 */
function doj_migration_prepare_workbench_settings($entity, $row) {
  $entity->is_new = !isset($row->migrate_map_needs_update);
  $entity->revision = TRUE;
  $entity->workbench_moderation_state_current = 'published';
  $entity->workbench_moderation_state_new = 'published';
}

/**
 * Ensure imported node revision is marked published (status = 1).
 *
 * This fixes a migrate/workbench issue where imported
 * published nodes have node_revision.status == 0.
 *
 * Must use db_query() as db_update() doesn't implement join().
 */
function doj_migration_complete_workbench_settings($entity, $row) {
  db_query("UPDATE {node_revision} nr
JOIN {node} n ON (n.vid = nr.vid AND n.nid = :nid)
SET nr.status = 1 WHERE n.status = 1 AND nr.status = 0",
    array(':nid' => $entity->nid));
}

/**
 * Helper function to audit thre redirects of an organization's content.
 *
 * This function checks all of the content for a given organization. The
 * default report (a bunch of print statements) let us know when there is a
 * change during the audit. When a redirect fails it will be logged, and if
 * the redirects are successfully created again that will be logged too. The
 * report might look something like this:
 *
 * 26236:TRUE:1
 * 28191:FALSE:392
 * 29626:FALSE:679
 *
 * The report always shows were we are starting, so node/26236 is the first
 * that is part of the given org, and TRUE tell us that it has a redirect.
 *
 * Then we see that node/28191 does not have a redirect, and that it is the
 * 392nd node in the org.
 *
 * finally, the last event is logged, since we never went back to TRUE, this
 * means that all nodes from the 392nd to the 679th all are missing
 * redirects.
 *
 * If the print_redirect flas is set to TRUE, all of the redirects for the
 * nodes that have them will be printed.
 *
 * @param int $org_id
 *   The nid of an organization node.
 * @param bool $print_redirects
 *   Whether we want to show the redirects or not.
 */
function doj_migration_redirect_check($org_id, $print_redirects = FALSE) {
  // @todo Integrate this kind of functionality with the migrate message
  // system.
  // Get all org nodes.
  $query = new EntityFieldQuery();
  $query->entityCondition("entity_type", "node");
  $query->entityCondition("bundle", "page");
  $query->fieldCondition("og_group_ref", "target_id", $org_id);
  $results = $query->execute();

  $r = NULL;
  $print = TRUE;
  $count = 0;
  foreach ($results['node'] as $nid => $info) {
    $count++;
    $node = node_load($nid);
    $uri = entity_uri("node", $node);
    $path = $uri['path'];
    $redirects = redirect_load_multiple(FALSE, array('redirect' => $path));

    if ($print_redirects) {
      foreach ($redirects as $redirect) {
        print_r($redirect->source . "\n");
      }
    }

    if ($r == TRUE && empty($redirects)) {
      $print = TRUE;
    }
    elseif ($r == FALSE && !empty($redirects)) {
      $print = TRUE;
    }

    if ($print) {
      $r = empty($redirects) ? FALSE : TRUE;
      print_r("{$node->nid}:");
      if ($r) {
        print_r("TRUE:{$count}\n");
      }
      else {
        print_r("FALSE:{$count}\n");
      }
      $print = FALSE;
    }
  }
  $r = empty($redirects) ? FALSE : TRUE;
  print_r("{$node->nid}:");
  if ($r) {
    print_r("TRUE:{$count}\n");
  }
  else {
    print_r("FALSE:{$count}\n");
  }
}
