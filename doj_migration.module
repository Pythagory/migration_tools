<?php

/**
 * @file
 * THIS SPACE INTENTIONALLY LEFT BLANK.
 *
 * Yes, there is no code in the .module file. Migrate operates almost entirely
 * through classes, and by adding any files containing class definitions to the
 * .info file, those files are automatically included only when the classes they
 * contain are referenced. The one non-class piece you need to implement is
 * hook_migrate_api(), but because .migrate.inc is registered using
 * hook_hook_info by defining your implementation of that hook in
 * mymodule.migrate.inc, it is automatically invoked only when needed.
 *
 * @package doj_migration
 */

/**
 * Implements hook_menu_alter().
 */
function doj_migration_menu_alter(&$items) {
  // Viewing this page calls the contstructors for all registered migration
  // classes, overwhelming PHP memory limit. We cannot disable migrate_ui
  // due to wordpress_migrate dependency on it, so we will instead unset this
  // menu router item.
  unset($items['admin/content/migrate']);
}

/**
 * Set workbench configration for entity.
 *
 * This fixes a number of bugs that result from worbench revisions failing
 * to be created or updated when entities are created or updated.
 */
function doj_migration_prepare_workbench_settings($entity, $row) {
  $entity->is_new = !isset($row->migrate_map_needs_update);
  $entity->revision = TRUE;
  $entity->workbench_moderation_state_current = 'published';
  $entity->workbench_moderation_state_new = 'published';
}

/**
 * Ensure imported node revision is marked published (status = 1).
 *
 * This fixes a migrate/workbench issue where imported
 * published nodes have node_revision.status == 0.
 *
 * Must use db_query() as db_update() doesn't implement join().
 */
function doj_migration_complete_workbench_settings($entity, $row) {
  db_query("UPDATE {node_revision} nr
JOIN {node} n ON (n.vid = nr.vid AND n.nid = :nid)
SET nr.status = 1 WHERE n.status = 1 AND nr.status = 0",
    array(':nid' => $entity->nid));
}

/**
 * Decodes all HTML entities, including numeric and hexadecimal ones.
 *
 * @param mixed $string
 *   A string.
 *
 * @return string
 *   decoded HTML.
 */
function doj_migration_html_entity_decode_numeric($string, $quote_style = ENT_COMPAT, $charset = "utf-8") {
  $string = html_entity_decode($string, $quote_style, $charset);
  $string = preg_replace_callback('~&#x([0-9a-fA-F]+);~i', "doj_migration_chr_utf8_callback", $string);
  $string = preg_replace('~&#([0-9]+);~e', 'doj_migration_chr_utf8("\\1")', $string);
  return $string;
}

/**
 * Callback helper.
 */
function doj_migration_chr_utf8_callback($matches) {
  return doj_migration_chr_utf8(hexdec($matches[1]));
}

/**
 * Multi-byte chr(): Will turn a numeric argument into a UTF-8 string.
 *
 * @param mixed $num
 *   A number.
 *
 * @return string
 *   The char represented by the number.
 */
function doj_migration_chr_utf8($num) {
  if ($num < 128) {
    return chr($num);
  }
  if ($num < 2048) {
    return chr(($num >> 6) + 192) . chr(($num & 63) + 128);
  }
  if ($num < 65536) {
    return chr(($num >> 12) + 224) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
  }
  if ($num < 2097152) {
    return chr(($num >> 18) + 240) . chr((($num >> 12) & 63) + 128) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
  }
  return '';
}
